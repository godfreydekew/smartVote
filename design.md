
# Design Document: Anonymous Voting with Merkle Trees

## 1. Introduction

This document outlines the design for implementing an anonymous voting system within the SmartVote application. The primary objective is to decouple user identity from their votes, ensuring that even if the system is compromised, the anonymity of voters is preserved.

## 2. The Problem with the Current Approach

The current implementation uses the thirdweb SDK, which links a user's email address to their wallet address. This creates a potential privacy issue. If thirdweb's infrastructure is breached, the link between a user's email and their wallet address could be exposed, and consequently, their vote could be deanonymized.

## 3. Proposed Solution: Merkle Trees and a Simple Verifier

To address this, we will implement a system based on Merkle trees and a simple on-chain verifier. This approach will allow voters to prove their eligibility to vote without revealing their identity, and without the complexity of ZK-SNARKs.

### 3.1. Core Concepts

*   **Merkle Tree:** A Merkle tree is a cryptographic data structure in which each leaf node is a hash of a block of data, and each non-leaf node is a hash of its children. The root of the tree is a single hash that represents the entire dataset. In our case, the leaves of the tree will be the public keys of the eligible voters.
*   **Merkle Proof:** A Merkle proof is a small amount of data that allows a verifier to confirm that a specific piece of data is part of a Merkle tree. In our case, a voter will provide a Merkle proof to show that their public key is in the tree of eligible voters.
*   **Nullifier:** A nullifier is a unique value that is used to prevent double-voting. Each voter will have a unique nullifier for each election. The nullifier is generated by hashing the voter's secret key and the election ID. This ensures that the nullifier is unique for each voter and each election, but does not reveal the voter's identity. When a voter casts a vote, they will reveal the nullifier. The smart contract will keep a record of all used nullifiers and will reject any vote that uses a nullifier that has already been used.

### 3.2. Workflow

1.  **Election Creation:** When an election is created, the backend will generate a Merkle tree of all eligible voters' public keys. The root of this tree will be stored in the `Election` smart contract.
2.  **Voter Registration:** A voter will register for an election by providing their public key. The backend will add the voter's public key to the list of eligible voters for that election.
3.  **Voting:**
    a. The voter's client-side application (frontend) will request the Merkle proof for their public key from the backend.
    b. The frontend will also generate a nullifier by hashing the user's secret key and the election ID.
    c. The frontend will send the Merkle proof, the vote itself, and the nullifier to the backend.
    d. The backend will submit the proof, the vote, and the nullifier to the `Election` smart contract.
4.  **Vote Verification:**
    a. The `Election` smart contract will verify the Merkle proof against the Merkle root.
    b. The smart contract will check if the nullifier has already been used.
    c. If the proof is valid and the nullifier has not been used, the vote will be accepted and the nullifier will be marked as used. Otherwise, the vote will be rejected.

## 4. System Architecture

The system will consist of the following components:

*   **Frontend:** A React application that allows users to view elections, register to vote, and cast their votes. It will use the `ethers.js` library to interact with the smart contract.
*   **Backend:** A Node.js application that handles user authentication, election management, and communication with the blockchain. It will use the `merkletreejs` library to generate Merkle trees and proofs.
*   **Blockchain:** An Ethereum-based blockchain that hosts the `Election` smart contract. The smart contract will include a simple Merkle proof verifier.

## 5. Database Schema

The following tables will be added to the database:

*   `elections`
    *   `id` (Primary Key)
    *   `merkle_root` (VARCHAR)
*   `election_voters`
    *   `id` (Primary Key)
    *   `election_id` (Foreign Key to `elections`)
    *   `public_key` (VARCHAR)

